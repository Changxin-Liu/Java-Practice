package pacman.ghost;

import pacman.game.Entity;
import pacman.game.PacmanGame;
import pacman.util.Direction;
import pacman.util.Position;

import java.util.*;

/**
 * An Abstract Ghost which is a game entity.
 *
 * @ass1
 */
public abstract class Ghost extends Entity {

    // whether the ghost is dead
    private boolean dead;
    // current phase of this ghost
    private Phase phase;
    // duration of current phase
    private int phaseDuration;

    /**
     * Creates a ghost which is alive and starts in the SCATTER phase
     * with a duration of Phase.SCATTER.duration(). This ghost also has
     * a default position of (0, 0) and a default direction of facing
     * up.
     *
     * @ass1
     */
    public Ghost() {
        super();
        dead = false;
        phase = Phase.SCATTER;
        phaseDuration = Phase.SCATTER.getDuration();
    }

    /**
     * Sets the Ghost Phase and its duration overriding any current
     * phase information.
     *
     * if Phase is null then no changes are made. If the duration is
     * less than zero then the duration is set to 0.
     *
     * @param newPhase to set the ghost to.
     * @param duration of ticks for the phase to last for.
     * @ass1
     */
    public void setPhase(Phase newPhase, int duration) {
        if (newPhase != null) {
            phase = newPhase;
            phaseDuration = Integer.max(0, duration);
        }
    }

    /**
     * Get the phase that the ghost currently is in.
     * @return the set phase.
     * @ass1
     */
    public Phase getPhase() {
        return phase;
    }

    /*
     * NextPhase decreases our phase duration and moves us to the
     * next phase if it is 0.
     *
     * - CHASE goes to SCATTER.
     * - FRIGHTENED && SCATTER go to CHASE.
     */
    private void nextPhase() {
        phaseDuration = Integer.max(0, phaseDuration - 1);
        if (phaseDuration == 0) {
            switch (getPhase()) {
                case CHASE:
                    setPhase(Phase.SCATTER, Phase.SCATTER.getDuration());
                    break;
                case FRIGHTENED:
                case SCATTER:
                    setPhase(Phase.CHASE, Phase.CHASE.getDuration());
                    break;
            }
        }
    }

    /**
     * Gets the phase info of the ghost.
     * @return the phase and duration formatted as such: "PHASE:DURATION".
     * @ass1
     */
    public String phaseInfo() {
        return String.format("%s:%d", phase, phaseDuration);
    }

    /**
     * Gets the ghosts colour.
     * @return hex version of the ghosts colour, e.g. #FFFFFF for white.
     * @ass1
     */
    public abstract String getColour();

    /**
     * Gets the ghosts type.
     * @return this ghosts type.
     * @ass1
     */
    public abstract GhostType getType();

    /**
     * Kills this ghost by setting its status to isDead.
     * @ass1
     */
    public void kill() {
        this.dead = true;
    }

    /**
     * Checks if this ghost is dead.
     * @return true if dead, false otherwise.
     * @ass1
     */
    public boolean isDead() {
        return dead;
    }

    /**
     * Resets the ghost back to an initial state where:
     *
     * <ul>
     *     <li>It is alive</li>
     *     <li>With a Phase of SCATTER with duration SCATTER.getDuration()</li>
     *     <li>Facing in the Direction.UP</li>
     *     <li>With a Position of ( 0, 0 )</li>
     * </ul>
     * @ass1
     */
    public void reset() {
        dead = false;
        this.phase = Phase.SCATTER;
        this.phaseDuration = Phase.SCATTER.getDuration();
        this.setDirection(Direction.UP);
        this.setPosition(new Position(0, 0));
    }

    public abstract Position chaseTarget(PacmanGame game);

    public abstract Position home(PacmanGame game);

    @Override
    public void move(PacmanGame game) {
        nextPhase();

        Position targetPosition;
        Direction direction = null;

        if (this.getPhase() == Phase.CHASE){
            targetPosition = chaseTarget(game);
        }else if (this.getPhase() == Phase.SCATTER){
            targetPosition = home(game);
        }else {
            targetPosition = new Position(this.getPosition().getX() * 24 %
                    (2 * game.getBoard().getWidth() -
                            game.getBoard().getWidth()),
                    this.getPosition().getY() * 36 %
                            (2 * game.getBoard().getHeight()) -
                            game.getBoard().getHeight());
        }

        Position currentPosition = this.getPosition();
        Direction currentDirection = this.getDirection();
        if (currentDirection == Direction.UP ||
                currentDirection == Direction.DOWN){
            double targetLeftDistance = targetPosition.distance
                    (currentPosition.add(Direction.LEFT.offset()));
            double targetRightDistance = targetPosition.distance
                    (currentPosition.add(Direction.RIGHT.offset()));
            double targetCurrentDirectionDistance =
                    targetPosition.distance
                            (currentPosition.add(currentDirection.offset()));
            double minDistanceLeftRight = compareDistance(targetLeftDistance,
                    targetRightDistance,
                    targetCurrentDirectionDistance);
            if (targetLeftDistance == targetRightDistance){
                if (targetCurrentDirectionDistance < targetLeftDistance){
                    direction = currentDirection;
                }else {
                    direction = Direction.LEFT;
                }
            }

            if (currentDirection == Direction.UP){
                if (targetCurrentDirectionDistance == targetLeftDistance ||
                        targetCurrentDirectionDistance == targetRightDistance){
                    direction = Direction.UP;
                }
            }else {
                if (targetCurrentDirectionDistance == targetLeftDistance){
                    direction = Direction.LEFT;
                }else if(targetCurrentDirectionDistance == targetRightDistance){
                    direction = Direction.DOWN;
                }
            }
            if (targetLeftDistance != targetRightDistance &&
                    targetCurrentDirectionDistance != targetLeftDistance &&
                    targetCurrentDirectionDistance != targetRightDistance) {
                if (minDistanceLeftRight == targetLeftDistance) {
                    direction = Direction.LEFT;
                } else if (minDistanceLeftRight == targetRightDistance) {
                    direction = Direction.RIGHT;
                } else {
                    direction = currentDirection;
                }
            }

        }else if (currentDirection == Direction.LEFT ||
                currentDirection == Direction.RIGHT){
            double targetUpDistance = targetPosition.distance
                    (currentPosition.add(Direction.UP.offset()));
            double targetDownDistance = targetPosition.distance
                    (currentPosition.add(Direction.DOWN.offset()));
            double targetCurrentDirectionDistance =
                    targetPosition.distance
                            (currentPosition.add(currentDirection.offset()));
            double minDistanceUpDown = compareDistance(targetUpDistance,
                    targetDownDistance,
                    targetCurrentDirectionDistance);

            if (targetUpDistance == targetDownDistance){
                if (targetCurrentDirectionDistance < targetUpDistance){
                    direction = currentDirection;
                }else {
                    direction = Direction.UP;
                }
            }

            if (currentDirection == Direction.LEFT){
                if (targetCurrentDirectionDistance == targetUpDistance){
                    direction = Direction.UP;
                }else if (targetCurrentDirectionDistance == targetDownDistance){
                    direction = Direction.LEFT;
                }
            }else {
                if (targetCurrentDirectionDistance == targetUpDistance){
                    direction = Direction.UP;
                }else if(targetCurrentDirectionDistance == targetDownDistance){
                    direction = Direction.DOWN;
                }
            }
            if (targetCurrentDirectionDistance != targetDownDistance &&
                    targetCurrentDirectionDistance != targetUpDistance &&
                    targetDownDistance != targetUpDistance){
                if (minDistanceUpDown == targetUpDistance){
                    direction = Direction.UP;
                }else if (minDistanceUpDown == targetDownDistance){
                    direction = Direction.DOWN;
                }else {
                    direction = currentDirection;
                }
            }


        }
        this.setDirection(direction);
        Position forwardPosition = currentPosition.add(direction.offset());
        if (game.getBoard().getEntry(forwardPosition).getPathable() &&
                forwardPosition.getX() < game.getBoard().getWidth() &&
                forwardPosition.getY() < game.getBoard().getHeight()){
            this.setPosition(forwardPosition);
        }



//        Direction opposite = currentDirection.opposite();
//
//        Position currentPosition = this.getPosition();
//        Position currentUp = currentPosition.add(Direction.UP.offset());
//        Position currentLeft = currentPosition.add(Direction.LEFT.offset());
//        Position currentDown = currentPosition.add(Direction.DOWN.offset());
//        Position currentRight = currentPosition.add(Direction.RIGHT.offset());
//        double targetUpDistance = targetPosition.distance(currentUp);
//        double targetLeftDistance = targetPosition.distance(currentLeft);
//        double targetRightDistance = targetPosition.distance(currentRight);
//        double targetDownDistance = targetPosition.distance(currentDown);
    }

    @Override
    public boolean equals(Object o){
        if (!(o instanceof Ghost)){
            return false;
        }
        return (this.isDead() == ((Ghost) o).isDead()) &&
                (this.phaseDuration == ((Ghost) o).phaseDuration) &&
                (this.getPhase() == ((Ghost) o).getPhase()) &&
                (this.getDirection() == ((Ghost) o).getDirection()) &&
                (this.getPosition().getX() == ((Ghost) o).getPosition().getX()) &&
                (this.getPosition().getY() == ((Ghost) o).getPosition().getY());
    }

    @Override
    public int hashCode(){
        int dead = 0;

        if (this.isDead()){
            dead = 1;
        }

        return 3 * dead + 5 * this.phaseDuration +
                7 * this.getPhase().hashCode() +
                11 * getDirection().hashCode() + 13 * getPosition().hashCode();
    }

    @Override
    public String toString(){
        return String.format("%d,%d,%s,%s",
                this.getPosition().getX(),
                this.getPosition().getY(),
                this.getDirection(),
                this.getPhase() + ":" + this.phaseDuration);
    }

    private double compareDistance(double first, double second,
                                      double third){
        double min = first;
        int count = 0;

        if (min > second){
            min = second;
        }

        if (min > third){
            min = third;
        }
        return min;
    }


}
